import os
import logging
import time
from datetime import datetime
from flask import Flask, request, jsonify
from flask_cors import CORS
from prometheus_client import Counter, Histogram, generate_latest
from dotenv import load_dotenv
from pydantic import BaseModel, ValidationError, Field

# Load environment
load_dotenv()

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

app = Flask(__name__)
CORS(app)

# Prometheus Metrics
requests_total = Counter(
    'classifier_requests_total',
    'Total classification requests',
    ['method', 'endpoint', 'status']
)

classification_duration = Histogram(
    'classifier_duration_seconds',
    'Time spent processing classification',
    ['category']
)

errors_total = Counter(
    'classifier_errors_total',
    'Total error count',
    ['error_type']
)

# Pydantic Models
class TicketRequest(BaseModel):
    ticket: str = Field(..., min_length=1, max_length=5000)

class BatchTicketRequest(BaseModel):
    tickets: list = Field(..., min_items=1, max_items=100)

# Import provider
try:
    from providers.multi_provider import MultiProvider
    provider = MultiProvider()
    logger.info("✅ Multi-Provider system initialized")
except Exception as e:
    logger.error(f"❌ Failed to initialize provider: {e}")
    provider = None

# Import and register auth blueprint
try:
    from api.auth import auth_bp
    app.register_blueprint(auth_bp)
    logger.info("✅ Auth blueprint registered")
except Exception as e:
    logger.error(f"⚠️  Auth blueprint not available: {e}")

# Import auth middleware
try:
    from middleware.auth import optional_api_key, require_api_key
    logger.info("✅ Auth middleware loaded")
except Exception as e:
    logger.error(f"⚠️  Auth middleware not available: {e}")
    # Fallback decorators
    optional_api_key = lambda f: f
    require_api_key = lambda f: f

@app.before_request
def before_request():
    request.start_time = time.time()

@app.after_request
def after_request(response):
    if hasattr(request, 'start_time'):
        duration = time.time() - request.start_time
        requests_total.labels(
            method=request.method,
            endpoint=request.endpoint or 'unknown',
            status=response.status_code
        ).inc()
    
    logger.info("Request completed")
    return response

@app.route('/api/v1/health', methods=['GET'])
def health():
    """Health check endpoint"""
    logger.info("Health check called")
    
    provider_status = {}
    if provider:
        try:
            provider_status = {'gemini': 'available'}
        except Exception as e:
            provider_status = {'gemini': f'error: {str(e)}'}
    
    return jsonify({
        'status': 'healthy',
        'timestamp': datetime.utcnow().isoformat() + 'Z',
        'version': '1.0.0',
        'provider_status': provider_status
    }), 200

@app.route('/api/v1/classify', methods=['POST'])
@optional_api_key
def classify():
    """Classify a support ticket"""
    start_time = time.time()
    
    try:
        data = TicketRequest(**request.json)
        ticket_text = data.ticket
        
        logger.info(f"Classifying ticket: {ticket_text[:50]}...")
        
        if not provider:
            errors_total.labels(error_type='provider_unavailable').inc()
            return jsonify({'error': 'Provider not available'}), 500
        
        result = provider.classify(ticket_text)
        category = result.get('category', 'Other')
        
        processing_time = time.time() - start_time
        classification_duration.labels(category=category).observe(processing_time)
        
        response = {
            'category': category,
            'confidence': result.get('confidence', 0.95),
            'priority': result.get('priority', 'medium'),
            'processing_time': round(processing_time, 3),
            'provider': result.get('provider', 'gemini')
        }
        
        logger.info(f"Classification completed: {category} in {processing_time:.3f}s")
        return jsonify(response), 200
        
    except ValidationError as e:
        errors_total.labels(error_type='validation_error').inc()
        logger.warning(f"Validation error: {e}")
        return jsonify({'error': str(e.errors()[0]['msg'])}), 400
    except Exception as e:
        errors_total.labels(error_type='classification_error').inc()
        logger.error(f"Classification error: {e}")
        return jsonify({'error': 'Classification failed', 'details': str(e)}), 500

@app.route('/api/v1/batch', methods=['POST'])
@optional_api_key
def batch_classify():
    """Classify multiple tickets at once"""
    start_time = time.time()
    
    try:
        data = BatchTicketRequest(**request.json)
        tickets = data.tickets
        
        logger.info(f"Batch classifying {len(tickets)} tickets")
        
        results = []
        successful = 0
        failed = 0
        
        for ticket in tickets:
            try:
                result = provider.classify(ticket)
                results.append({
                    'category': result.get('category', 'Other'),
                    'confidence': result.get('confidence', 0.95),
                    'priority': result.get('priority', 'medium')
                })
                successful += 1
            except Exception as e:
                results.append({'error': str(e)})
                failed += 1
        
        processing_time = time.time() - start_time
        
        return jsonify({
            'results': results,
            'total': len(tickets),
            'successful': successful,
            'failed': failed,
            'processing_time': round(processing_time, 3)
        }), 200
        
    except ValidationError as e:
        return jsonify({'error': str(e.errors()[0]['msg'])}), 400
    except Exception as e:
        logger.error(f"Batch classification error: {e}")
        return jsonify({'error': 'Batch classification failed'}), 500

@app.route('/metrics', methods=['GET'])
def metrics():
    """Prometheus metrics endpoint"""
    return generate_latest(), 200, {'Content-Type': 'text/plain; charset=utf-8'}

@app.errorhandler(404)
def not_found(error):
    return jsonify({'error': 'Endpoint not found'}), 404

@app.errorhandler(500)
def internal_error(error):
    return jsonify({'error': 'Internal server error'}), 500

if __name__ == '__main__':
    port = int(os.getenv('PORT', 5000))
    debug = os.getenv('ENVIRONMENT', 'production') != 'production'
    
    logger.info(f"Starting AI Ticket Classifier API on port {port}")
    app.run(host='0.0.0.0', port=port, debug=debug)
